# 프로토타입(Prototype)
Javascript는 Java, C++처럼 클래스 기반 객체지향 프로그래밍 언어가 아닌 **프로토타입 기반 객체지향 프로그래밍 언어**이다.

여기서 `프로토타입(Prototype)`이란 무엇일까? Javascript의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 이것은 클래스 기반 객체지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 여기서 말하는 '부모 객체'가 자바스크립트의 **프로토타입 객체**인 것이다. 프로토타입 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다.

## [[Prototype]]
모든 객체는 숨겨진 [[Prototype]]이라는 프로퍼티를 가지고 있다. (__proto__와 같음) 이 프로퍼티는 해당 객체의 프로토타입을 가리키는 프로퍼티이다. 함수 객체는 [[Prototype]] 프로퍼티뿐만 아니라 `prototype` 프로퍼티도 가지고 있는데, 이 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 프로토타입 객체를 가리킨다.

## constructor
프로토타입 객체가 가지는 프로퍼티이다. 이 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다.

``` JavaScript
function Student(school) {
    this.school = school;
}

var chaeeun = new Student('DSM');

console.log(Student.prototype.constructor === Person); // Student() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Student() 생성자 함수

console.log(chaeeun.constructor === Person); // chaeeun 객체를 생성한 객체는 Student() 생성자 함수

console.log(Student.constructor === Function); // Student() 생성자 함수를 생성한 객체는 Fucntion() 생성자 함수
```

## 프로토타입 체인
프로토타입 체인은 특정 객체의 프로퍼티나 메소드에 접근하려 할 때 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색하는 것을 말한다. 이를 통해 JavaScript의 모든 객체는 `Object` 객체가 가지고 있는 메소드와 프로퍼티를 사용할 수 있다.

``` Javascript
var person = {
    name: 'Hyunjae',
    job: 'singer',
    sex: 'male'
};

console.log(person.hasOwnProperty('name'));
```
`person` 객체는 `hasOwnProperty` 메소드를 가지고 있지 않으나 `person` 객체의 [[Prototype]] 프로퍼티가 가리키는 링크를 따라가서 `person` 객체의 프로토타입 객체의 메소드 `hasOwnProperty`를 호출하여 사용한다.

### 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인
객체 리터럴로 생성된 객체는 내장 함수인 `Object()` 생정자 함수로 객체를 생성하는 것을 단순화한 것이다. JS 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 `Object()` 생성자 함수를 사용하여 객체를 생성한다.

`Object()` 생성자 함수는 함수 객체이므로 일반 객체와 달리 `prototype` 프로퍼티를 가지고 있다.

``` Javascript
var tvxq = {
    leader: 'U-know',
    notleader: 'MAX',
    famoussaying: function(){
        console.log('벌레 중에 가장 안 좋은 벌레는 대충이다');
    }
};

console.dir(person);

console.log(tvxq.__proto__ === Object.prototype); // 1
console.log(Object.prototype.constructor === Object); // 2
console.log(Object.__proto__ === Function.prototype); // 3
console.log(Function.prototype.__proto__ === Object.prototype) // 4
```
`tvxq` 객체는 객체 리터럴 방식으로 생성했으므로 내부적으로 `Object()` 생성자를 통해 객체를 생성한 셈이다.

1. `tvxq.__proto__`는 `tvxq` 객체의 숨겨진 [[Prototype]] 프로퍼티를 뜻하고, 이 프로퍼티는 `tvxq` 객체의 프로토타입 객체를 가리킨다. `tvxq` 객체의 프로토타입 객체는 `Object.prototype`이다.
2. `Object.prototype.constructor`는 `Object()` 함수가 생성자로서 사용되었을 때 생성되는 객체의 프로토타입을 가리키는 `Object.prototype`의 `constructor` 프로퍼티를 뜻하고, `constructor` 프로퍼티는 위에서 언급했듯 프로토타입 객체가 가지는 프로퍼티이고, 객체의 입장에서 자신을 생성한 객체를 가리킨다. `Object.prototype`을 생성한 객체는 `Object()` 생성자 함수(함수도 객체라는 것을 잊지 말자)이므로 `Object.prototype.constructor`는 `Object`와 같다.
3. `Object.__proto__`는 `Object()` 생성자 함수의 프로토타입을 뜻한다. `Object()` 생성자 함수의 프로토타입은 `Function.prototype`이다.
4. `Function.prototype.__proto__`는 `Function.prototype`의 프로토타입을 가리킨다. `Function.prototype`의 프로토타입은 `Object.prototype`이다.

> 객체 리터럴을 사용하여 객체를 생성한 경우: 그 객체의 프로토타입 객체는 `Object.prototype`이다.

### 생성자 함수로 생성된 객체의 프로토타입 체인
함수 정의 방식 세 가지(함수선언식, 함수표현식, 함수 리터럴 방식)는 내부적으로 모두 `Function()` 생성자 함수를 통해 함수 객체를 생성한 것이다. 따라서 어떤 방식으로 함수 객체를 생성하든 모든 함수 객체의 `prototype` 객체는 `Function.prototype`이다. 생성자 함수도 함수 객체이므로 포함이다.

## 기본 자료형의 확장 (wrapper object)
## 프로토타입 체이닝 동작 조건
## 프로토타입 객체 변경
# 재귀
## 재귀함수란?
함수 내에서 자기 자신을 다시 호출하는 함수를 말한다.

``` C
void Recursive(void)
{
    printf("나를 다시 호출해!\n");
    Recursive();
}
```
위의 함수는 아래 사진과 같이 동작한다.
![재귀함수](./재귀함수의흐름.png)
> `Recursive` 함수를 실행하는 중간에 다시 `Recursive` 함수가 호출되면, `Recursive` 함수의 복사본을 하나 더 만들어서 복사본을 실행하게 된다.

실제로 함수를 구성하는 명령문은 CPU로 복사되어 실행된다. 그렇기 때문에 함수 실행 중간에 다시 함수를 호출할 수 있는 것이다.

하지만 위의 코드는 한 번 호출되면 무한 루프에 걸리는 문제가 생긴다. 이럴 때는 탈출 조건을 만들어 주면 된다.

``` C
#include <stdio.h>

void Recursive(int num)
{
    if(num <= 0) // 재귀의 탈출 조건
        return; // 재귀의 탈출
    printf("나를 %d번 호출해!\n", num);
    Recursive(num - 1);
}

int main()
{
    Recursive(3);
    return 0;
}
```

실행 결과는 아래와 같다.

```
나를 3번 호출해!
나를 2번 호출해!
나를 1번 호출해!
```
## 재귀의 활용
### 피보나치 수열(Fibonacci Sequence)
피보나치 수열은 아래와 같다.

```
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 . . .
```

간단히 말하면 **앞의 수를 두 개 더해 현재의 수를 만들어 가는 수열**이다. 일반화하면 다음과 같다.

```
수열의 n번째 값 = 수열의 n-1번째 값 + 수열의 n-2번째 값 // 수열의 n번째 값은 수열의 첫 번째와 두 번째 값을 제외한다
```

이를 코드로 옮기면 다음과 같다.

``` C
int Fibo(int n) // 피보나치 수열의 n번째 값 반환
{
    if(n == 1) // 피보나치 수열의 첫 번째 값을 요구하면
        return 0; // 0 반환
    else if(n == 2) // 두 번째 값을 요구하면
        return 1; // 1 반환
    else // 세 번째 이후의 값을 요구하면
        return Fibo(n - 1) + Fibo(n - 2);
}
```

## 하노이 타워(The Tower of Hanoi)
